"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[517],{4482:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"Observability/jaeger","title":"Jaeger","description":"Jaeger is an open-source distributed tracing system for monitoring and troubleshooting microservices. Learn how to set up Jaeger for comprehensive application observability.","source":"@site/docs/Observability/jaeger.md","sourceDirName":"Observability","slug":"/Observability/Jaeger","permalink":"/docs/Observability/Jaeger","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Observability/jaeger.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"title":"Jaeger","description":"Jaeger is an open-source distributed tracing system for monitoring and troubleshooting microservices. Learn how to set up Jaeger for comprehensive application observability.","slug":"/Observability/Jaeger","keywords":["Jaeger","distributed tracing","microservices monitoring","observability","OpenTracing","performance monitoring","request tracing","service mesh","application monitoring","troubleshooting"]},"sidebar":"tutorialSidebar","previous":{"title":"ELK Stack (Elastic Stack)","permalink":"/docs/Observability/ELKStack"},"next":{"title":"Splunk","permalink":"/docs/Observability/Splunk"}}');var s=r(4848),a=r(8453);const i={sidebar_position:6,title:"Jaeger",description:"Jaeger is an open-source distributed tracing system for monitoring and troubleshooting microservices. Learn how to set up Jaeger for comprehensive application observability.",slug:"/Observability/Jaeger",keywords:["Jaeger","distributed tracing","microservices monitoring","observability","OpenTracing","performance monitoring","request tracing","service mesh","application monitoring","troubleshooting"]},o="\ud83d\ude80 Distributed Tracing and Monitoring with Jaeger",c={},l=[{value:"\ud83e\uddf0 Prerequisites",id:"-prerequisites",level:2},{value:"\ud83d\udd27 Step 1: Setup Jaeger with Docker Compose",id:"-step-1-setup-jaeger-with-docker-compose",level:2},{value:"All-in-One Jaeger Deployment",id:"all-in-one-jaeger-deployment",level:3},{value:"Production Jaeger Deployment",id:"production-jaeger-deployment",level:3},{value:"OpenTelemetry Collector Configuration",id:"opentelemetry-collector-configuration",level:3},{value:"\ud83c\udfd7\ufe0f Step 2: Instrument Applications for Tracing",id:"\ufe0f-step-2-instrument-applications-for-tracing",level:2},{value:"Node.js Application Instrumentation",id:"nodejs-application-instrumentation",level:3},{value:"Python Application Instrumentation",id:"python-application-instrumentation",level:3},{value:"\u25b6\ufe0f Step 3: Kubernetes Deployment",id:"\ufe0f-step-3-kubernetes-deployment",level:2},{value:"Jaeger Operator Deployment",id:"jaeger-operator-deployment",level:3},{value:"Application Deployment with Sidecar",id:"application-deployment-with-sidecar",level:3},{value:"\ud83d\udcca Step 4: Advanced Tracing Configuration",id:"-step-4-advanced-tracing-configuration",level:2},{value:"Custom Sampling Strategies",id:"custom-sampling-strategies",level:3},{value:"Jaeger Configuration with Sampling",id:"jaeger-configuration-with-sampling",level:3},{value:"\ud83d\udd0d Step 5: Monitoring and Alerting",id:"-step-5-monitoring-and-alerting",level:2},{value:"Jaeger Metrics and Monitoring",id:"jaeger-metrics-and-monitoring",level:3},{value:"Grafana Dashboard for Jaeger",id:"grafana-dashboard-for-jaeger",level:3},{value:"\ud83d\udccb Common Use Cases",id:"-common-use-cases",level:2},{value:"1. <strong>Microservices Debugging</strong>",id:"1-microservices-debugging",level:3},{value:"2. <strong>Performance Optimization</strong>",id:"2-performance-optimization",level:3},{value:"3. <strong>System Reliability</strong>",id:"3-system-reliability",level:3},{value:"4. <strong>Business Intelligence</strong>",id:"4-business-intelligence",level:3},{value:"\u2705 What You&#39;ll Achieve",id:"-what-youll-achieve",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"-distributed-tracing-and-monitoring-with-jaeger",children:"\ud83d\ude80 Distributed Tracing and Monitoring with Jaeger"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Jaeger"})," is an ",(0,s.jsx)(n.strong,{children:"open-source"})," distributed tracing system for ",(0,s.jsx)(n.strong,{children:"monitoring"})," and ",(0,s.jsx)(n.strong,{children:"troubleshooting"})," microservices-based distributed systems. Perfect for ",(0,s.jsx)(n.strong,{children:"observability"}),", ",(0,s.jsx)(n.strong,{children:"performance analysis"}),", and ",(0,s.jsx)(n.strong,{children:"debugging"})," complex ",(0,s.jsx)(n.strong,{children:"service interactions"})," with comprehensive ",(0,s.jsx)(n.strong,{children:"trace visualization"}),"."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"-prerequisites",children:"\ud83e\uddf0 Prerequisites"}),"\n",(0,s.jsx)(n.p,{children:"Make sure you have the following:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Docker & Docker Compose"})," installed"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Kubernetes cluster"})," (optional, for production deployment)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Microservices application"})," to monitor"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Basic understanding"})," of distributed systems"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"OpenTracing/OpenTelemetry"})," knowledge (helpful)"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"-step-1-setup-jaeger-with-docker-compose",children:"\ud83d\udd27 Step 1: Setup Jaeger with Docker Compose"}),"\n",(0,s.jsx)(n.h3,{id:"all-in-one-jaeger-deployment",children:"All-in-One Jaeger Deployment"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Create docker-compose.yml:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'version: \'3.8\'\n\nservices:\n  # Jaeger All-in-One (for development/testing)\n  jaeger-all-in-one:\n    image: jaegertracing/all-in-one:1.51\n    container_name: jaeger\n    restart: unless-stopped\n    ports:\n      - "16686:16686"  # Jaeger UI\n      - "14268:14268"  # HTTP collector\n      - "14250:14250"  # gRPC collector\n      - "6831:6831/udp"  # UDP agent\n      - "6832:6832/udp"  # UDP agent\n      - "5778:5778"   # Config server\n    environment:\n      - COLLECTOR_OTLP_ENABLED=true\n      - COLLECTOR_ZIPKIN_HOST_PORT=:9411\n    command: [\n      "--memory.max-traces=50000",\n      "--query.base-path=/jaeger/ui"\n    ]\n\n  # Sample microservices for demonstration\n  frontend:\n    image: jaegertracing/example-hotrod:1.51\n    container_name: hotrod-frontend\n    restart: unless-stopped\n    ports:\n      - "8080:8080"\n    environment:\n      - JAEGER_AGENT_HOST=jaeger-all-in-one\n      - JAEGER_AGENT_PORT=6831\n    depends_on:\n      - jaeger-all-in-one\n    command: ["all"]\n\n  # OpenTelemetry Collector (optional)\n  otel-collector:\n    image: otel/opentelemetry-collector-contrib:0.89.0\n    container_name: otel-collector\n    restart: unless-stopped\n    ports:\n      - "4317:4317"   # OTLP gRPC receiver\n      - "4318:4318"   # OTLP HTTP receiver\n      - "8888:8888"   # Prometheus metrics\n      - "8889:8889"   # Prometheus exporter metrics\n    volumes:\n      - ./otel-collector-config.yaml:/etc/otelcol-contrib/otel-collector-config.yaml\n    command: ["--config=/etc/otelcol-contrib/otel-collector-config.yaml"]\n    depends_on:\n      - jaeger-all-in-one\n\nvolumes:\n  jaeger-data:\n'})}),"\n",(0,s.jsx)(n.h3,{id:"production-jaeger-deployment",children:"Production Jaeger Deployment"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Create docker-compose.prod.yml:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'version: \'3.8\'\n\nservices:\n  # Elasticsearch for storage\n  elasticsearch:\n    image: docker.elastic.co/elasticsearch/elasticsearch:8.11.0\n    container_name: jaeger-elasticsearch\n    restart: unless-stopped\n    environment:\n      - discovery.type=single-node\n      - xpack.security.enabled=false\n      - "ES_JAVA_OPTS=-Xms1g -Xmx1g"\n    ports:\n      - "9200:9200"\n    volumes:\n      - elasticsearch-data:/usr/share/elasticsearch/data\n    healthcheck:\n      test: ["CMD-SHELL", "curl -f http://localhost:9200/_cluster/health || exit 1"]\n      interval: 30s\n      timeout: 10s\n      retries: 5\n\n  # Jaeger Collector\n  jaeger-collector:\n    image: jaegertracing/jaeger-collector:1.51\n    container_name: jaeger-collector\n    restart: unless-stopped\n    ports:\n      - "14269:14269"  # Admin port\n      - "14268:14268"  # HTTP collector\n      - "14250:14250"  # gRPC collector\n      - "9411:9411"    # Zipkin compatible\n    environment:\n      - SPAN_STORAGE_TYPE=elasticsearch\n      - ES_SERVER_URLS=http://elasticsearch:9200\n      - ES_NUM_SHARDS=1\n      - ES_NUM_REPLICAS=0\n      - COLLECTOR_OTLP_ENABLED=true\n    depends_on:\n      elasticsearch:\n        condition: service_healthy\n    command: [\n      "--es.num-shards=1",\n      "--es.num-replicas=0",\n      "--collector.otlp.enabled=true"\n    ]\n\n  # Jaeger Query Service\n  jaeger-query:\n    image: jaegertracing/jaeger-query:1.51\n    container_name: jaeger-query\n    restart: unless-stopped\n    ports:\n      - "16686:16686"  # Jaeger UI\n      - "16687:16687"  # Admin port\n    environment:\n      - SPAN_STORAGE_TYPE=elasticsearch\n      - ES_SERVER_URLS=http://elasticsearch:9200\n      - ES_NUM_SHARDS=1\n      - ES_NUM_REPLICAS=0\n    depends_on:\n      elasticsearch:\n        condition: service_healthy\n    command: [\n      "--es.num-shards=1",\n      "--es.num-replicas=0"\n    ]\n\n  # Jaeger Agent\n  jaeger-agent:\n    image: jaegertracing/jaeger-agent:1.51\n    container_name: jaeger-agent\n    restart: unless-stopped\n    ports:\n      - "5775:5775/udp"  # Zipkin Thrift\n      - "6831:6831/udp"  # Jaeger Thrift\n      - "6832:6832/udp"  # Jaeger binary\n      - "5778:5778"      # Config server\n    environment:\n      - REPORTER_GRPC_HOST_PORT=jaeger-collector:14250\n    depends_on:\n      - jaeger-collector\n    command: [\n      "--reporter.grpc.host-port=jaeger-collector:14250"\n    ]\n\nvolumes:\n  elasticsearch-data:\n'})}),"\n",(0,s.jsx)(n.h3,{id:"opentelemetry-collector-configuration",children:"OpenTelemetry Collector Configuration"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Create otel-collector-config.yaml:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'receivers:\n  otlp:\n    protocols:\n      grpc:\n        endpoint: 0.0.0.0:4317\n      http:\n        endpoint: 0.0.0.0:4318\n  \n  jaeger:\n    protocols:\n      grpc:\n        endpoint: 0.0.0.0:14250\n      thrift_http:\n        endpoint: 0.0.0.0:14268\n      thrift_compact:\n        endpoint: 0.0.0.0:6831\n      thrift_binary:\n        endpoint: 0.0.0.0:6832\n\n  zipkin:\n    endpoint: 0.0.0.0:9411\n\nprocessors:\n  batch:\n    timeout: 1s\n    send_batch_size: 1024\n    send_batch_max_size: 2048\n\n  memory_limiter:\n    limit_mib: 512\n\n  resource:\n    attributes:\n      - key: environment\n        value: production\n        action: upsert\n\nexporters:\n  jaeger:\n    endpoint: jaeger-collector:14250\n    tls:\n      insecure: true\n\n  prometheus:\n    endpoint: "0.0.0.0:8889"\n\n  logging:\n    loglevel: info\n\nservice:\n  pipelines:\n    traces:\n      receivers: [otlp, jaeger, zipkin]\n      processors: [memory_limiter, resource, batch]\n      exporters: [jaeger, logging]\n    \n    metrics:\n      receivers: [otlp]\n      processors: [memory_limiter, resource, batch]\n      exporters: [prometheus, logging]\n\n  extensions: [health_check, pprof, zpages]\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"\ufe0f-step-2-instrument-applications-for-tracing",children:"\ud83c\udfd7\ufe0f Step 2: Instrument Applications for Tracing"}),"\n",(0,s.jsx)(n.h3,{id:"nodejs-application-instrumentation",children:"Node.js Application Instrumentation"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Create nodejs-tracing.js:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const { NodeSDK } = require('@opentelemetry/sdk-node');\nconst { getNodeAutoInstrumentations } = require('@opentelemetry/auto-instrumentations-node');\nconst { JaegerExporter } = require('@opentelemetry/exporter-jaeger');\nconst { Resource } = require('@opentelemetry/resources');\nconst { SemanticResourceAttributes } = require('@opentelemetry/semantic-conventions');\n\n// Initialize Jaeger exporter\nconst jaegerExporter = new JaegerExporter({\n  endpoint: process.env.JAEGER_ENDPOINT || 'http://localhost:14268/api/traces',\n});\n\n// Initialize OpenTelemetry SDK\nconst sdk = new NodeSDK({\n  resource: new Resource({\n    [SemanticResourceAttributes.SERVICE_NAME]: process.env.SERVICE_NAME || 'nodejs-service',\n    [SemanticResourceAttributes.SERVICE_VERSION]: process.env.SERVICE_VERSION || '1.0.0',\n    [SemanticResourceAttributes.DEPLOYMENT_ENVIRONMENT]: process.env.ENVIRONMENT || 'development',\n  }),\n  traceExporter: jaegerExporter,\n  instrumentations: [\n    getNodeAutoInstrumentations({\n      // Disable file system instrumentation (too noisy)\n      '@opentelemetry/instrumentation-fs': {\n        enabled: false,\n      },\n      // Configure HTTP instrumentation\n      '@opentelemetry/instrumentation-http': {\n        enabled: true,\n        ignoreIncomingRequestHook: (req) => {\n          // Ignore health check endpoints\n          return req.url?.includes('/health') || req.url?.includes('/metrics');\n        },\n      },\n      // Configure Express instrumentation\n      '@opentelemetry/instrumentation-express': {\n        enabled: true,\n      },\n    }),\n  ],\n});\n\n// Start the SDK\nsdk.start();\n\nconsole.log('OpenTelemetry tracing initialized');\n\n// Graceful shutdown\nprocess.on('SIGTERM', () => {\n  sdk.shutdown()\n    .then(() => console.log('Tracing terminated'))\n    .catch((error) => console.log('Error terminating tracing', error))\n    .finally(() => process.exit(0));\n});\n\n// Sample Express application\nconst express = require('express');\nconst axios = require('axios');\nconst { trace, context } = require('@opentelemetry/api');\n\nconst app = express();\nconst port = process.env.PORT || 3000;\n\n// Middleware\napp.use(express.json());\n\n// Custom tracing example\napp.get('/api/users/:id', async (req, res) => {\n  const tracer = trace.getTracer('user-service');\n  \n  // Create a custom span\n  const span = tracer.startSpan('get-user-details');\n  \n  try {\n    // Add span attributes\n    span.setAttributes({\n      'user.id': req.params.id,\n      'http.method': req.method,\n      'http.url': req.url,\n    });\n    \n    // Simulate database call\n    const user = await getUserFromDatabase(req.params.id);\n    \n    // Add more attributes based on result\n    span.setAttributes({\n      'user.found': !!user,\n      'user.name': user?.name || 'unknown',\n    });\n    \n    if (user) {\n      // Make external API call with tracing context\n      const enrichedUser = await context.with(trace.setSpan(context.active(), span), async () => {\n        return await enrichUserData(user);\n      });\n      \n      res.json(enrichedUser);\n    } else {\n      span.recordException(new Error('User not found'));\n      span.setStatus({ code: trace.SpanStatusCode.ERROR, message: 'User not found' });\n      res.status(404).json({ error: 'User not found' });\n    }\n  } catch (error) {\n    // Record exception in span\n    span.recordException(error);\n    span.setStatus({ code: trace.SpanStatusCode.ERROR, message: error.message });\n    res.status(500).json({ error: 'Internal server error' });\n  } finally {\n    // Always end the span\n    span.end();\n  }\n});\n\n// Simulate database operation\nasync function getUserFromDatabase(userId) {\n  const tracer = trace.getTracer('database');\n  const span = tracer.startSpan('db.query.select_user');\n  \n  try {\n    span.setAttributes({\n      'db.system': 'postgresql',\n      'db.statement': 'SELECT * FROM users WHERE id = $1',\n      'db.operation': 'select',\n      'db.table': 'users',\n    });\n    \n    // Simulate database delay\n    await new Promise(resolve => setTimeout(resolve, Math.random() * 100));\n    \n    // Mock user data\n    const user = {\n      id: userId,\n      name: `User ${userId}`,\n      email: `user${userId}@example.com`,\n      created_at: new Date().toISOString(),\n    };\n    \n    span.setAttributes({\n      'db.rows_affected': 1,\n    });\n    \n    return user;\n  } catch (error) {\n    span.recordException(error);\n    span.setStatus({ code: trace.SpanStatusCode.ERROR, message: error.message });\n    throw error;\n  } finally {\n    span.end();\n  }\n}\n\n// Simulate external API call\nasync function enrichUserData(user) {\n  const tracer = trace.getTracer('external-api');\n  const span = tracer.startSpan('external.api.user_profile');\n  \n  try {\n    span.setAttributes({\n      'http.method': 'GET',\n      'http.url': `https://api.example.com/profiles/${user.id}`,\n      'external.service': 'profile-service',\n    });\n    \n    // Simulate external API call\n    await new Promise(resolve => setTimeout(resolve, Math.random() * 200));\n    \n    // Mock enriched data\n    const enrichedData = {\n      ...user,\n      profile: {\n        avatar: `https://avatars.example.com/${user.id}`,\n        bio: `Bio for ${user.name}`,\n        followers: Math.floor(Math.random() * 1000),\n      },\n    };\n    \n    span.setAttributes({\n      'http.status_code': 200,\n      'profile.followers': enrichedData.profile.followers,\n    });\n    \n    return enrichedData;\n  } catch (error) {\n    span.recordException(error);\n    span.setStatus({ code: trace.SpanStatusCode.ERROR, message: error.message });\n    throw error;\n  } finally {\n    span.end();\n  }\n}\n\n// Health check endpoint\napp.get('/health', (req, res) => {\n  res.json({ status: 'healthy', timestamp: new Date().toISOString() });\n});\n\n// Error handling middleware\napp.use((error, req, res, next) => {\n  const span = trace.getActiveSpan();\n  if (span) {\n    span.recordException(error);\n    span.setStatus({ code: trace.SpanStatusCode.ERROR, message: error.message });\n  }\n  \n  console.error('Unhandled error:', error);\n  res.status(500).json({ error: 'Internal server error' });\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"python-application-instrumentation",children:"Python Application Instrumentation"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Create python-tracing.py:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import os\nimport time\nimport random\nfrom flask import Flask, request, jsonify\nimport requests\nimport psycopg2\nfrom opentelemetry import trace\nfrom opentelemetry.sdk.trace import TracerProvider\nfrom opentelemetry.sdk.trace.export import BatchSpanProcessor\nfrom opentelemetry.exporter.jaeger.thrift import JaegerExporter\nfrom opentelemetry.sdk.resources import Resource\nfrom opentelemetry.semconv.resource import ResourceAttributes\nfrom opentelemetry.instrumentation.flask import FlaskInstrumentor\nfrom opentelemetry.instrumentation.requests import RequestsInstrumentor\nfrom opentelemetry.instrumentation.psycopg2 import Psycopg2Instrumentor\n\n# Configure OpenTelemetry\nresource = Resource.create({\n    ResourceAttributes.SERVICE_NAME: os.getenv(\'SERVICE_NAME\', \'python-service\'),\n    ResourceAttributes.SERVICE_VERSION: os.getenv(\'SERVICE_VERSION\', \'1.0.0\'),\n    ResourceAttributes.DEPLOYMENT_ENVIRONMENT: os.getenv(\'ENVIRONMENT\', \'development\'),\n})\n\n# Initialize tracer provider\ntrace.set_tracer_provider(TracerProvider(resource=resource))\ntracer_provider = trace.get_tracer_provider()\n\n# Configure Jaeger exporter\njaeger_exporter = JaegerExporter(\n    agent_host_name=os.getenv(\'JAEGER_AGENT_HOST\', \'localhost\'),\n    agent_port=int(os.getenv(\'JAEGER_AGENT_PORT\', \'6831\')),\n)\n\n# Add span processor\nspan_processor = BatchSpanProcessor(jaeger_exporter)\ntracer_provider.add_span_processor(span_processor)\n\n# Get tracer\ntracer = trace.get_tracer(__name__)\n\n# Initialize Flask app\napp = Flask(__name__)\n\n# Auto-instrument Flask, Requests, and Psycopg2\nFlaskInstrumentor().instrument_app(app)\nRequestsInstrumentor().instrument()\nPsycopg2Instrumentor().instrument()\n\nclass DatabaseService:\n    def __init__(self):\n        self.connection_string = os.getenv(\n            \'DATABASE_URL\', \n            \'postgresql://user:password@localhost:5432/mydb\'\n        )\n    \n    def get_user(self, user_id):\n        """Get user from database with tracing"""\n        with tracer.start_as_current_span("db.get_user") as span:\n            span.set_attributes({\n                "db.system": "postgresql",\n                "db.operation": "select",\n                "db.table": "users",\n                "user.id": user_id,\n            })\n            \n            try:\n                # Simulate database connection and query\n                time.sleep(random.uniform(0.01, 0.1))  # Simulate DB latency\n                \n                # Mock user data\n                user = {\n                    "id": user_id,\n                    "name": f"User {user_id}",\n                    "email": f"user{user_id}@example.com",\n                    "created_at": "2024-01-01T00:00:00Z"\n                }\n                \n                span.set_attributes({\n                    "db.rows_affected": 1,\n                    "user.name": user["name"],\n                })\n                \n                return user\n                \n            except Exception as e:\n                span.record_exception(e)\n                span.set_status(trace.Status(trace.StatusCode.ERROR, str(e)))\n                raise\n\nclass ExternalAPIService:\n    def __init__(self):\n        self.base_url = os.getenv(\'EXTERNAL_API_URL\', \'https://api.example.com\')\n    \n    def enrich_user_data(self, user):\n        """Enrich user data from external API"""\n        with tracer.start_as_current_span("external.api.enrich_user") as span:\n            span.set_attributes({\n                "http.method": "GET",\n                "http.url": f"{self.base_url}/profiles/{user[\'id\']}",\n                "external.service": "profile-service",\n                "user.id": user["id"],\n            })\n            \n            try:\n                # Simulate external API call\n                time.sleep(random.uniform(0.05, 0.2))  # Simulate API latency\n                \n                # Mock enriched data\n                enriched_user = {\n                    **user,\n                    "profile": {\n                        "avatar": f"https://avatars.example.com/{user[\'id\']}",\n                        "bio": f"Bio for {user[\'name\']}",\n                        "followers": random.randint(0, 1000),\n                        "verified": random.choice([True, False])\n                    }\n                }\n                \n                span.set_attributes({\n                    "http.status_code": 200,\n                    "profile.followers": enriched_user["profile"]["followers"],\n                    "profile.verified": enriched_user["profile"]["verified"],\n                })\n                \n                return enriched_user\n                \n            except Exception as e:\n                span.record_exception(e)\n                span.set_status(trace.Status(trace.StatusCode.ERROR, str(e)))\n                raise\n\n# Initialize services\ndb_service = DatabaseService()\napi_service = ExternalAPIService()\n\n@app.route(\'/api/users/<int:user_id>\')\ndef get_user(user_id):\n    """Get user endpoint with comprehensive tracing"""\n    with tracer.start_as_current_span("get_user_handler") as span:\n        span.set_attributes({\n            "http.method": request.method,\n            "http.url": request.url,\n            "http.route": "/api/users/<int:user_id>",\n            "user.id": user_id,\n        })\n        \n        try:\n            # Get user from database\n            user = db_service.get_user(user_id)\n            \n            if not user:\n                span.set_attributes({"user.found": False})\n                span.set_status(trace.Status(trace.StatusCode.ERROR, "User not found"))\n                return jsonify({"error": "User not found"}), 404\n            \n            span.set_attributes({\n                "user.found": True,\n                "user.name": user["name"],\n            })\n            \n            # Enrich user data\n            enriched_user = api_service.enrich_user_data(user)\n            \n            # Add response attributes\n            span.set_attributes({\n                "http.status_code": 200,\n                "response.size": len(str(enriched_user)),\n            })\n            \n            return jsonify(enriched_user)\n            \n        except Exception as e:\n            span.record_exception(e)\n            span.set_status(trace.Status(trace.StatusCode.ERROR, str(e)))\n            return jsonify({"error": "Internal server error"}), 500\n\n@app.route(\'/api/users/<int:user_id>/orders\')\ndef get_user_orders(user_id):\n    """Get user orders with distributed tracing"""\n    with tracer.start_as_current_span("get_user_orders") as span:\n        span.set_attributes({\n            "user.id": user_id,\n            "operation": "get_orders",\n        })\n        \n        try:\n            # Simulate multiple database queries\n            with tracer.start_as_current_span("db.get_orders") as db_span:\n                db_span.set_attributes({\n                    "db.system": "postgresql",\n                    "db.operation": "select",\n                    "db.table": "orders",\n                })\n                \n                time.sleep(random.uniform(0.02, 0.15))\n                \n                # Mock orders data\n                orders = [\n                    {\n                        "id": i,\n                        "user_id": user_id,\n                        "product": f"Product {i}",\n                        "amount": random.uniform(10, 500),\n                        "status": random.choice(["pending", "completed", "cancelled"])\n                    }\n                    for i in range(1, random.randint(1, 10))\n                ]\n                \n                db_span.set_attributes({\n                    "db.rows_affected": len(orders),\n                    "orders.count": len(orders),\n                })\n            \n            # Calculate order statistics\n            with tracer.start_as_current_span("calculate_order_stats") as calc_span:\n                total_amount = sum(order["amount"] for order in orders)\n                completed_orders = len([o for o in orders if o["status"] == "completed"])\n                \n                calc_span.set_attributes({\n                    "orders.total_amount": total_amount,\n                    "orders.completed_count": completed_orders,\n                })\n            \n            response = {\n                "user_id": user_id,\n                "orders": orders,\n                "summary": {\n                    "total_orders": len(orders),\n                    "total_amount": total_amount,\n                    "completed_orders": completed_orders,\n                }\n            }\n            \n            span.set_attributes({\n                "http.status_code": 200,\n                "orders.total_count": len(orders),\n                "orders.total_amount": total_amount,\n            })\n            \n            return jsonify(response)\n            \n        except Exception as e:\n            span.record_exception(e)\n            span.set_status(trace.Status(trace.StatusCode.ERROR, str(e)))\n            return jsonify({"error": "Internal server error"}), 500\n\n@app.route(\'/health\')\ndef health_check():\n    """Health check endpoint"""\n    return jsonify({\n        "status": "healthy",\n        "service": "python-service",\n        "timestamp": time.time()\n    })\n\n@app.errorhandler(Exception)\ndef handle_exception(e):\n    """Global exception handler with tracing"""\n    span = trace.get_current_span()\n    if span:\n        span.record_exception(e)\n        span.set_status(trace.Status(trace.StatusCode.ERROR, str(e)))\n    \n    return jsonify({"error": "Internal server error"}), 500\n\nif __name__ == \'__main__\':\n    port = int(os.getenv(\'PORT\', 5000))\n    app.run(host=\'0.0.0.0\', port=port, debug=True)\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"\ufe0f-step-3-kubernetes-deployment",children:"\u25b6\ufe0f Step 3: Kubernetes Deployment"}),"\n",(0,s.jsx)(n.h3,{id:"jaeger-operator-deployment",children:"Jaeger Operator Deployment"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Create jaeger-operator.yaml:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Namespace\nmetadata:\n  name: observability\n---\napiVersion: jaegertracing.io/v1\nkind: Jaeger\nmetadata:\n  name: jaeger-production\n  namespace: observability\nspec:\n  strategy: production\n  \n  collector:\n    maxReplicas: 5\n    resources:\n      limits:\n        cpu: 1000m\n        memory: 1Gi\n      requests:\n        cpu: 500m\n        memory: 512Mi\n    \n  query:\n    replicas: 2\n    resources:\n      limits:\n        cpu: 500m\n        memory: 512Mi\n      requests:\n        cpu: 250m\n        memory: 256Mi\n    \n  storage:\n    type: elasticsearch\n    elasticsearch:\n      nodeCount: 3\n      redundancyPolicy: SingleRedundancy\n      resources:\n        limits:\n          cpu: 1000m\n          memory: 2Gi\n        requests:\n          cpu: 500m\n          memory: 1Gi\n      storage:\n        size: 10Gi\n        storageClassName: fast-ssd\n    \n  ingress:\n    enabled: true\n    annotations:\n      kubernetes.io/ingress.class: nginx\n      cert-manager.io/cluster-issuer: letsencrypt-prod\n    hosts:\n      - jaeger.example.com\n    tls:\n      - secretName: jaeger-tls\n        hosts:\n          - jaeger.example.com\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: jaeger-collector-headless\n  namespace: observability\n  labels:\n    app: jaeger\n    component: collector\nspec:\n  clusterIP: None\n  ports:\n  - name: grpc\n    port: 14250\n    protocol: TCP\n    targetPort: 14250\n  - name: http\n    port: 14268\n    protocol: TCP\n    targetPort: 14268\n  - name: zipkin\n    port: 9411\n    protocol: TCP\n    targetPort: 9411\n  selector:\n    app: jaeger\n    component: collector\n"})}),"\n",(0,s.jsx)(n.h3,{id:"application-deployment-with-sidecar",children:"Application Deployment with Sidecar"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Create app-with-jaeger.yaml:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: sample-app\n  namespace: default\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: sample-app\n  template:\n    metadata:\n      labels:\n        app: sample-app\n      annotations:\n        sidecar.jaegertracing.io/inject: "true"\n    spec:\n      containers:\n      - name: app\n        image: your-registry/sample-app:latest\n        ports:\n        - containerPort: 8080\n        env:\n        - name: JAEGER_AGENT_HOST\n          value: "localhost"\n        - name: JAEGER_AGENT_PORT\n          value: "6831"\n        - name: JAEGER_SERVICE_NAME\n          value: "sample-app"\n        - name: JAEGER_SAMPLER_TYPE\n          value: "const"\n        - name: JAEGER_SAMPLER_PARAM\n          value: "1"\n        resources:\n          limits:\n            cpu: 500m\n            memory: 512Mi\n          requests:\n            cpu: 250m\n            memory: 256Mi\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 8080\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /health\n            port: 8080\n          initialDelaySeconds: 5\n          periodSeconds: 5\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: sample-app-service\nspec:\n  selector:\n    app: sample-app\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: 8080\n  type: ClusterIP\n\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: sample-app-ingress\n  annotations:\n    kubernetes.io/ingress.class: nginx\n    nginx.ingress.kubernetes.io/rewrite-target: /\nspec:\n  rules:\n  - host: app.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: sample-app-service\n            port:\n              number: 80\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"-step-4-advanced-tracing-configuration",children:"\ud83d\udcca Step 4: Advanced Tracing Configuration"}),"\n",(0,s.jsx)(n.h3,{id:"custom-sampling-strategies",children:"Custom Sampling Strategies"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Create sampling-strategies.json:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "service_strategies": [\n    {\n      "service": "frontend-service",\n      "type": "probabilistic",\n      "param": 1.0,\n      "max_traces_per_second": 100\n    },\n    {\n      "service": "user-service",\n      "type": "probabilistic",\n      "param": 0.5,\n      "max_traces_per_second": 50\n    },\n    {\n      "service": "payment-service",\n      "type": "probabilistic",\n      "param": 1.0,\n      "max_traces_per_second": 200,\n      "operation_strategies": [\n        {\n          "operation": "process-payment",\n          "type": "probabilistic",\n          "param": 1.0\n        },\n        {\n          "operation": "validate-card",\n          "type": "probabilistic",\n          "param": 0.8\n        }\n      ]\n    },\n    {\n      "service": "notification-service",\n      "type": "probabilistic",\n      "param": 0.1,\n      "max_traces_per_second": 10\n    }\n  ],\n  "default_strategy": {\n    "type": "probabilistic",\n    "param": 0.1,\n    "max_traces_per_second": 50\n  },\n  "per_operation_strategies": [\n    {\n      "service": "auth-service",\n      "operation": "login",\n      "type": "probabilistic",\n      "param": 1.0\n    },\n    {\n      "service": "auth-service",\n      "operation": "refresh-token",\n      "type": "probabilistic",\n      "param": 0.1\n    }\n  ]\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"jaeger-configuration-with-sampling",children:"Jaeger Configuration with Sampling"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Create jaeger-config.yaml:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: jaeger-configuration\n  namespace: observability\ndata:\n  sampling-strategies.json: |\n    {\n      "service_strategies": [\n        {\n          "service": "critical-service",\n          "type": "probabilistic",\n          "param": 1.0,\n          "max_traces_per_second": 1000\n        },\n        {\n          "service": "background-service",\n          "type": "probabilistic",\n          "param": 0.01,\n          "max_traces_per_second": 10\n        }\n      ],\n      "default_strategy": {\n        "type": "adaptive",\n        "param": 0.1,\n        "max_traces_per_second": 100\n      }\n    }\n\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: jaeger-collector\n  namespace: observability\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: jaeger-collector\n  template:\n    metadata:\n      labels:\n        app: jaeger-collector\n    spec:\n      containers:\n      - name: jaeger-collector\n        image: jaegertracing/jaeger-collector:1.51\n        ports:\n        - containerPort: 14268\n        - containerPort: 14250\n        - containerPort: 9411\n        env:\n        - name: SPAN_STORAGE_TYPE\n          value: elasticsearch\n        - name: ES_SERVER_URLS\n          value: "http://elasticsearch:9200"\n        - name: COLLECTOR_OTLP_ENABLED\n          value: "true"\n        - name: SAMPLING_STRATEGIES_FILE\n          value: "/etc/jaeger/sampling-strategies.json"\n        volumeMounts:\n        - name: jaeger-config\n          mountPath: /etc/jaeger\n        resources:\n          limits:\n            cpu: 1000m\n            memory: 1Gi\n          requests:\n            cpu: 500m\n            memory: 512Mi\n      volumes:\n      - name: jaeger-config\n        configMap:\n          name: jaeger-configuration\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"-step-5-monitoring-and-alerting",children:"\ud83d\udd0d Step 5: Monitoring and Alerting"}),"\n",(0,s.jsx)(n.h3,{id:"jaeger-metrics-and-monitoring",children:"Jaeger Metrics and Monitoring"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Create jaeger-monitoring.yaml:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'apiVersion: v1\nkind: ServiceMonitor\nmetadata:\n  name: jaeger-collector\n  namespace: observability\n  labels:\n    app: jaeger-collector\nspec:\n  selector:\n    matchLabels:\n      app: jaeger-collector\n  endpoints:\n  - port: admin\n    interval: 30s\n    path: /metrics\n\n---\napiVersion: v1\nkind: ServiceMonitor\nmetadata:\n  name: jaeger-query\n  namespace: observability\n  labels:\n    app: jaeger-query\nspec:\n  selector:\n    matchLabels:\n      app: jaeger-query\n  endpoints:\n  - port: admin\n    interval: 30s\n    path: /metrics\n\n---\napiVersion: monitoring.coreos.com/v1\nkind: PrometheusRule\nmetadata:\n  name: jaeger-alerts\n  namespace: observability\nspec:\n  groups:\n  - name: jaeger.rules\n    rules:\n    - alert: JaegerCollectorDown\n      expr: up{job="jaeger-collector"} == 0\n      for: 5m\n      labels:\n        severity: critical\n      annotations:\n        summary: "Jaeger Collector is down"\n        description: "Jaeger Collector has been down for more than 5 minutes"\n\n    - alert: JaegerQueryDown\n      expr: up{job="jaeger-query"} == 0\n      for: 5m\n      labels:\n        severity: critical\n      annotations:\n        summary: "Jaeger Query is down"\n        description: "Jaeger Query service has been down for more than 5 minutes"\n\n    - alert: JaegerHighErrorRate\n      expr: rate(jaeger_collector_spans_rejected_total[5m]) > 0.1\n      for: 2m\n      labels:\n        severity: warning\n      annotations:\n        summary: "High span rejection rate in Jaeger Collector"\n        description: "Jaeger Collector is rejecting {{ $value }} spans per second"\n\n    - alert: JaegerStorageLatencyHigh\n      expr: histogram_quantile(0.95, rate(jaeger_collector_save_latency_bucket[5m])) > 1\n      for: 5m\n      labels:\n        severity: warning\n      annotations:\n        summary: "High storage latency in Jaeger"\n        description: "95th percentile storage latency is {{ $value }}s"\n\n    - alert: JaegerMemoryUsageHigh\n      expr: (container_memory_usage_bytes{pod=~"jaeger-.*"} / container_spec_memory_limit_bytes) > 0.8\n      for: 5m\n      labels:\n        severity: warning\n      annotations:\n        summary: "High memory usage in Jaeger component"\n        description: "Memory usage is above 80% for {{ $labels.pod }}"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"grafana-dashboard-for-jaeger",children:"Grafana Dashboard for Jaeger"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Create jaeger-dashboard.json:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "dashboard": {\n    "id": null,\n    "title": "Jaeger Tracing Dashboard",\n    "tags": ["jaeger", "tracing", "observability"],\n    "timezone": "browser",\n    "panels": [\n      {\n        "id": 1,\n        "title": "Traces per Second",\n        "type": "graph",\n        "targets": [\n          {\n            "expr": "rate(jaeger_collector_traces_received_total[5m])",\n            "legendFormat": "Traces Received",\n            "refId": "A"\n          },\n          {\n            "expr": "rate(jaeger_collector_spans_received_total[5m])",\n            "legendFormat": "Spans Received",\n            "refId": "B"\n          }\n        ],\n        "yAxes": [\n          {\n            "label": "Rate",\n            "min": 0\n          }\n        ],\n        "gridPos": {\n          "h": 8,\n          "w": 12,\n          "x": 0,\n          "y": 0\n        }\n      },\n      {\n        "id": 2,\n        "title": "Storage Latency",\n        "type": "graph",\n        "targets": [\n          {\n            "expr": "histogram_quantile(0.50, rate(jaeger_collector_save_latency_bucket[5m]))",\n            "legendFormat": "50th percentile",\n            "refId": "A"\n          },\n          {\n            "expr": "histogram_quantile(0.95, rate(jaeger_collector_save_latency_bucket[5m]))",\n            "legendFormat": "95th percentile",\n            "refId": "B"\n          },\n          {\n            "expr": "histogram_quantile(0.99, rate(jaeger_collector_save_latency_bucket[5m]))",\n            "legendFormat": "99th percentile",\n            "refId": "C"\n          }\n        ],\n        "yAxes": [\n          {\n            "label": "Latency (s)",\n            "min": 0\n          }\n        ],\n        "gridPos": {\n          "h": 8,\n          "w": 12,\n          "x": 12,\n          "y": 0\n        }\n      },\n      {\n        "id": 3,\n        "title": "Error Rates",\n        "type": "graph",\n        "targets": [\n          {\n            "expr": "rate(jaeger_collector_spans_rejected_total[5m])",\n            "legendFormat": "Spans Rejected",\n            "refId": "A"\n          },\n          {\n            "expr": "rate(jaeger_query_requests_total{result=\\"err\\"}[5m])",\n            "legendFormat": "Query Errors",\n            "refId": "B"\n          }\n        ],\n        "yAxes": [\n          {\n            "label": "Error Rate",\n            "min": 0\n          }\n        ],\n        "gridPos": {\n          "h": 8,\n          "w": 12,\n          "x": 0,\n          "y": 8\n        }\n      },\n      {\n        "id": 4,\n        "title": "Service Dependencies",\n        "type": "nodeGraph",\n        "targets": [\n          {\n            "expr": "jaeger_dependencies",\n            "refId": "A"\n          }\n        ],\n        "gridPos": {\n          "h": 8,\n          "w": 12,\n          "x": 12,\n          "y": 8\n        }\n      }\n    ],\n    "time": {\n      "from": "now-1h",\n      "to": "now"\n    },\n    "refresh": "30s"\n  }\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"-common-use-cases",children:"\ud83d\udccb Common Use Cases"}),"\n",(0,s.jsxs)(n.h3,{id:"1-microservices-debugging",children:["1. ",(0,s.jsx)(n.strong,{children:"Microservices Debugging"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Request flow visualization across services"}),"\n",(0,s.jsx)(n.li,{children:"Performance bottleneck identification"}),"\n",(0,s.jsx)(n.li,{children:"Error propagation analysis"}),"\n",(0,s.jsx)(n.li,{children:"Service dependency mapping"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"2-performance-optimization",children:["2. ",(0,s.jsx)(n.strong,{children:"Performance Optimization"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Latency analysis and optimization"}),"\n",(0,s.jsx)(n.li,{children:"Resource utilization monitoring"}),"\n",(0,s.jsx)(n.li,{children:"Database query performance"}),"\n",(0,s.jsx)(n.li,{children:"External API call optimization"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"3-system-reliability",children:["3. ",(0,s.jsx)(n.strong,{children:"System Reliability"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Error rate monitoring and alerting"}),"\n",(0,s.jsx)(n.li,{children:"Service health tracking"}),"\n",(0,s.jsx)(n.li,{children:"Capacity planning and scaling"}),"\n",(0,s.jsx)(n.li,{children:"Incident response and root cause analysis"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"4-business-intelligence",children:["4. ",(0,s.jsx)(n.strong,{children:"Business Intelligence"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"User journey tracking"}),"\n",(0,s.jsx)(n.li,{children:"Feature usage analytics"}),"\n",(0,s.jsx)(n.li,{children:"Performance impact analysis"}),"\n",(0,s.jsx)(n.li,{children:"A/B testing insights"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"-what-youll-achieve",children:"\u2705 What You'll Achieve"}),"\n",(0,s.jsx)(n.p,{children:"After following this guide, you'll have:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"\ud83c\udfd7\ufe0f Complete Tracing Infrastructure"})," - Production-ready Jaeger deployment"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"\ud83d\udd0d Application Instrumentation"})," - Comprehensive tracing for multiple languages"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"\ud83d\udcca Visual Trace Analysis"})," - Interactive trace visualization and analysis"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"\ud83d\ude80 Performance Monitoring"})," - Real-time performance metrics and alerting"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"\ud83d\udee1\ufe0f Error Tracking"})," - Distributed error tracking and debugging"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"\ud83d\udcc8 Service Dependencies"})," - Clear service interaction mapping"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"\ud83d\udd04 Continuous Monitoring"})," - Ongoing observability and health tracking"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"\ud83d\udc65 Team Collaboration"})," - Shared observability platform for development teams"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Jaeger is now configured for your distributed tracing and microservices monitoring workflows!"})]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>o});var t=r(6540);const s={},a=t.createContext(s);function i(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);