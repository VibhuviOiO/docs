"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7382],{8453:(n,e,s)=>{s.d(e,{R:()=>o,x:()=>a});var r=s(6540);const t={},i=r.createContext(t);function o(n){const e=r.useContext(i);return r.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:o(n.components),r.createElement(i.Provider,{value:e},n.children)}},9280:(n,e,s)=>{s.r(e),s.d(e,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"Infrastructure/bash","title":"Bash Scripting","description":"Bash is the most widely used Unix shell for automation, system administration, and DevOps workflows across Linux and macOS systems.","source":"@site/docs/Infrastructure/bash.md","sourceDirName":"Infrastructure","slug":"/Infrastructure/Bash","permalink":"/docs/docs/Infrastructure/Bash","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Infrastructure/bash.md","tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"sidebar_position":11,"title":"Bash Scripting","description":"Bash is the most widely used Unix shell for automation, system administration, and DevOps workflows across Linux and macOS systems.","slug":"/Infrastructure/Bash","keywords":["Bash","shell scripting","Linux automation","Unix shell","system administration","DevOps automation","command line","scripting"]},"sidebar":"tutorialSidebar","previous":{"title":"PowerShell","permalink":"/docs/docs/Infrastructure/PowerShell"},"next":{"title":"\ud83d\ude80 HashiCorp Nomad - Simple and Flexible Workload Orchestrator","permalink":"/docs/docs/Infrastructure/nomad"}}');var t=s(4848),i=s(8453);const o={sidebar_position:11,title:"Bash Scripting",description:"Bash is the most widely used Unix shell for automation, system administration, and DevOps workflows across Linux and macOS systems.",slug:"/Infrastructure/Bash",keywords:["Bash","shell scripting","Linux automation","Unix shell","system administration","DevOps automation","command line","scripting"]},a="\ud83d\ude80 System Automation with Bash Scripting",c={},l=[{value:"Key Features",id:"key-features",level:2},{value:"Use Cases",id:"use-cases",level:2},{value:"\ud83e\uddf0 Prerequisites",id:"-prerequisites",level:2},{value:"\ud83d\udd27 Step 1: Basic Bash Script Structure",id:"-step-1-basic-bash-script-structure",level:2},{value:"\ud83c\udfd7\ufe0f Step 2: Docker Management Script",id:"\ufe0f-step-2-docker-management-script",level:2},{value:"\ud83d\udcc1 Step 3: CI/CD Pipeline Script",id:"-step-3-cicd-pipeline-script",level:2},{value:"\u25b6\ufe0f Step 4: Run the Scripts",id:"\ufe0f-step-4-run-the-scripts",level:2},{value:"\ud83d\udd0d What You&#39;ll See",id:"-what-youll-see",level:2},{value:"System Monitor Output",id:"system-monitor-output",level:3},{value:"Docker Manager",id:"docker-manager",level:3},{value:"Deployment Pipeline",id:"deployment-pipeline",level:3},{value:"Pros &amp; Cons",id:"pros--cons",level:2},{value:"\u2705 Pros",id:"-pros",level:3},{value:"\u274c Cons",id:"-cons",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(n){const e={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"-system-automation-with-bash-scripting",children:"\ud83d\ude80 System Automation with Bash Scripting"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Bash (Bourne Again Shell)"})," is the most widely used ",(0,t.jsx)(e.strong,{children:"Unix shell"})," for ",(0,t.jsx)(e.strong,{children:"automation"}),", ",(0,t.jsx)(e.strong,{children:"system administration"}),", and ",(0,t.jsx)(e.strong,{children:"DevOps workflows"}),". Perfect for ",(0,t.jsx)(e.strong,{children:"Linux/macOS automation"}),", ",(0,t.jsx)(e.strong,{children:"CI/CD pipelines"}),", and ",(0,t.jsx)(e.strong,{children:"infrastructure management"})," with powerful ",(0,t.jsx)(e.strong,{children:"command-line"})," capabilities."]}),"\n",(0,t.jsx)(e.h2,{id:"key-features",children:"Key Features"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Universal"}),": Available on virtually all Linux/Unix systems"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Powerful"}),": Rich set of built-in commands and utilities"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Flexible"}),": Easy text processing and system interaction"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Lightweight"}),": Minimal resource usage"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Integration"}),": Works seamlessly with all Unix tools"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Portable"}),": Scripts run across different Unix-like systems"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"System Administration"}),": Server management and maintenance"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"CI/CD Pipelines"}),": Build and deployment automation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Infrastructure Automation"}),": Server provisioning and configuration"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Log Processing"}),": Text parsing and data extraction"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Backup Scripts"}),": Automated backup and recovery"]}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"-prerequisites",children:"\ud83e\uddf0 Prerequisites"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Linux/macOS"})," system with Bash installed"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Basic command-line"})," knowledge"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Text editor"})," (vim, nano, or VS Code)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Git"})," for version control (optional)"]}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"-step-1-basic-bash-script-structure",children:"\ud83d\udd27 Step 1: Basic Bash Script Structure"}),"\n",(0,t.jsxs)(e.p,{children:["Create a system monitoring script ",(0,t.jsx)(e.code,{children:"system-monitor.sh"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:'#!/bin/bash\n\n# System Monitoring Script\n# Description: Monitor system resources and generate reports\n\nset -euo pipefail  # Exit on error, undefined vars, pipe failures\n\n# Configuration\nLOG_FILE="/var/log/system-monitor.log"\nREPORT_DIR="./reports"\nDATE=$(date \'+%Y-%m-%d_%H-%M-%S\')\nHOSTNAME=$(hostname)\n\n# Colors for output\nRED=\'\\033[0;31m\'\nGREEN=\'\\033[0;32m\'\nYELLOW=\'\\033[1;33m\'\nBLUE=\'\\033[0;34m\'\nNC=\'\\033[0m\' # No Color\n\n# Logging function\nlog() {\n    local level=$1\n    shift\n    echo "$(date \'+%Y-%m-%d %H:%M:%S\') [$level] $*" | tee -a "$LOG_FILE"\n}\n\n# Error handling\nerror_exit() {\n    log "ERROR" "$1"\n    exit 1\n}\n\n# Check if running as root for certain operations\ncheck_root() {\n    if [[ $EUID -eq 0 ]]; then\n        log "INFO" "Running as root"\n        return 0\n    else\n        log "WARN" "Not running as root - some features may be limited"\n        return 1\n    fi\n}\n\n# System information gathering\nget_system_info() {\n    log "INFO" "Gathering system information..."\n    \n    cat << EOF\n=== SYSTEM INFORMATION ===\nHostname: $HOSTNAME\nDate: $(date)\nUptime: $(uptime)\nKernel: $(uname -r)\nOS: $(cat /etc/os-release | grep PRETTY_NAME | cut -d\'"\' -f2)\nArchitecture: $(uname -m)\nEOF\n}\n\n# Memory usage\nget_memory_info() {\n    log "INFO" "Checking memory usage..."\n    \n    echo "=== MEMORY USAGE ==="\n    free -h\n    echo\n    \n    # Memory usage percentage\n    local mem_usage=$(free | grep Mem | awk \'{printf "%.2f", $3/$2 * 100.0}\')\n    if (( $(echo "$mem_usage > 80" | bc -l) )); then\n        echo -e "${RED}WARNING: High memory usage: ${mem_usage}%${NC}"\n    else\n        echo -e "${GREEN}Memory usage: ${mem_usage}%${NC}"\n    fi\n}\n\n# Disk usage\nget_disk_info() {\n    log "INFO" "Checking disk usage..."\n    \n    echo "=== DISK USAGE ==="\n    df -h\n    echo\n    \n    # Check for high disk usage\n    while IFS= read -r line; do\n        usage=$(echo "$line" | awk \'{print $5}\' | sed \'s/%//\')\n        mount=$(echo "$line" | awk \'{print $6}\')\n        \n        if [[ "$usage" =~ ^[0-9]+$ ]] && [ "$usage" -gt 80 ]; then\n            echo -e "${RED}WARNING: High disk usage on $mount: ${usage}%${NC}"\n        fi\n    done < <(df -h | tail -n +2)\n}\n\n# CPU usage\nget_cpu_info() {\n    log "INFO" "Checking CPU usage..."\n    \n    echo "=== CPU INFORMATION ==="\n    lscpu | grep -E "Model name|CPU\\(s\\)|Thread|Core"\n    echo\n    \n    echo "=== CPU USAGE ==="\n    top -bn1 | grep "Cpu(s)" | awk \'{print $2}\' | sed \'s/%us,//\'\n    \n    # Load average\n    local load_avg=$(uptime | awk -F\'load average:\' \'{print $2}\')\n    echo "Load Average: $load_avg"\n}\n\n# Network information\nget_network_info() {\n    log "INFO" "Checking network information..."\n    \n    echo "=== NETWORK INTERFACES ==="\n    ip addr show | grep -E "inet |inet6 " | awk \'{print $2}\' | head -10\n    echo\n    \n    echo "=== NETWORK CONNECTIONS ==="\n    ss -tuln | head -10\n}\n\n# Service status\ncheck_services() {\n    log "INFO" "Checking service status..."\n    \n    local services=("nginx" "apache2" "mysql" "postgresql" "redis" "docker" "ssh")\n    \n    echo "=== SERVICE STATUS ==="\n    for service in "${services[@]}"; do\n        if systemctl is-active --quiet "$service" 2>/dev/null; then\n            echo -e "${GREEN}\u2713 $service: Running${NC}"\n        elif systemctl list-unit-files | grep -q "^$service.service"; then\n            echo -e "${RED}\u2717 $service: Stopped${NC}"\n        else\n            echo -e "${YELLOW}? $service: Not installed${NC}"\n        fi\n    done\n}\n\n# Generate HTML report\ngenerate_html_report() {\n    local report_file="$REPORT_DIR/system-report-$DATE.html"\n    \n    mkdir -p "$REPORT_DIR"\n    \n    cat > "$report_file" << EOF\n<!DOCTYPE html>\n<html>\n<head>\n    <title>System Report - $HOSTNAME</title>\n    <style>\n        body { font-family: Arial, sans-serif; margin: 20px; }\n        h1, h2 { color: #2c3e50; }\n        .status-ok { color: green; }\n        .status-warning { color: orange; }\n        .status-error { color: red; }\n        pre { background: #f4f4f4; padding: 10px; border-radius: 5px; }\n    </style>\n</head>\n<body>\n    <h1>System Report - $HOSTNAME</h1>\n    <p>Generated on: $(date)</p>\n    \n    <h2>System Information</h2>\n    <pre>$(get_system_info)</pre>\n    \n    <h2>Memory Usage</h2>\n    <pre>$(get_memory_info)</pre>\n    \n    <h2>Disk Usage</h2>\n    <pre>$(get_disk_info)</pre>\n    \n    <h2>CPU Information</h2>\n    <pre>$(get_cpu_info)</pre>\n    \n    <h2>Network Information</h2>\n    <pre>$(get_network_info)</pre>\n    \n    <h2>Service Status</h2>\n    <pre>$(check_services)</pre>\n</body>\n</html>\nEOF\n\n    log "INFO" "HTML report generated: $report_file"\n    echo -e "${GREEN}Report saved to: $report_file${NC}"\n}\n\n# Main execution\nmain() {\n    log "INFO" "Starting system monitoring script"\n    \n    echo -e "${BLUE}=== SYSTEM MONITORING REPORT ===${NC}"\n    echo "Generated on: $(date)"\n    echo "Hostname: $HOSTNAME"\n    echo\n    \n    get_system_info\n    echo\n    get_memory_info\n    echo\n    get_disk_info\n    echo\n    get_cpu_info\n    echo\n    get_network_info\n    echo\n    check_services\n    echo\n    \n    # Generate HTML report\n    generate_html_report\n    \n    log "INFO" "System monitoring completed"\n}\n\n# Script execution\nif [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then\n    main "$@"\nfi\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"\ufe0f-step-2-docker-management-script",children:"\ud83c\udfd7\ufe0f Step 2: Docker Management Script"}),"\n",(0,t.jsxs)(e.p,{children:["Create a Docker management script ",(0,t.jsx)(e.code,{children:"docker-manager.sh"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:'#!/bin/bash\n\n# Docker Management Script\nset -euo pipefail\n\n# Configuration\nDOCKER_COMPOSE_FILE="docker-compose.yml"\nLOG_FILE="./docker-manager.log"\n\n# Colors\nRED=\'\\033[0;31m\'\nGREEN=\'\\033[0;32m\'\nYELLOW=\'\\033[1;33m\'\nBLUE=\'\\033[0;34m\'\nNC=\'\\033[0m\'\n\n# Logging\nlog() {\n    echo "$(date \'+%Y-%m-%d %H:%M:%S\') - $*" | tee -a "$LOG_FILE"\n}\n\n# Check if Docker is installed and running\ncheck_docker() {\n    if ! command -v docker &> /dev/null; then\n        echo -e "${RED}Error: Docker is not installed${NC}"\n        exit 1\n    fi\n    \n    if ! docker info &> /dev/null; then\n        echo -e "${RED}Error: Docker daemon is not running${NC}"\n        exit 1\n    fi\n    \n    echo -e "${GREEN}\u2713 Docker is running${NC}"\n}\n\n# List containers\nlist_containers() {\n    local show_all=${1:-false}\n    \n    echo -e "${BLUE}=== DOCKER CONTAINERS ===${NC}"\n    \n    if [[ "$show_all" == "true" ]]; then\n        docker ps -a --format "table {{.ID}}\\t{{.Image}}\\t{{.Command}}\\t{{.Status}}\\t{{.Names}}"\n    else\n        docker ps --format "table {{.ID}}\\t{{.Image}}\\t{{.Command}}\\t{{.Status}}\\t{{.Names}}"\n    fi\n}\n\n# Container operations\nstart_container() {\n    local container_name=$1\n    \n    if docker start "$container_name" &> /dev/null; then\n        echo -e "${GREEN}\u2713 Container \'$container_name\' started${NC}"\n        log "Started container: $container_name"\n    else\n        echo -e "${RED}\u2717 Failed to start container \'$container_name\'${NC}"\n        return 1\n    fi\n}\n\nstop_container() {\n    local container_name=$1\n    \n    if docker stop "$container_name" &> /dev/null; then\n        echo -e "${GREEN}\u2713 Container \'$container_name\' stopped${NC}"\n        log "Stopped container: $container_name"\n    else\n        echo -e "${RED}\u2717 Failed to stop container \'$container_name\'${NC}"\n        return 1\n    fi\n}\n\n# Create and run container\ncreate_container() {\n    local image=$1\n    local name=$2\n    local port=${3:-""}\n    local env_vars=${4:-""}\n    \n    local docker_cmd="docker run -d --name $name"\n    \n    if [[ -n "$port" ]]; then\n        docker_cmd="$docker_cmd -p $port"\n    fi\n    \n    if [[ -n "$env_vars" ]]; then\n        docker_cmd="$docker_cmd $env_vars"\n    fi\n    \n    docker_cmd="$docker_cmd $image"\n    \n    echo "Running: $docker_cmd"\n    \n    if eval "$docker_cmd" &> /dev/null; then\n        echo -e "${GREEN}\u2713 Container \'$name\' created and started${NC}"\n        log "Created container: $name from image: $image"\n    else\n        echo -e "${RED}\u2717 Failed to create container \'$name\'${NC}"\n        return 1\n    fi\n}\n\n# Docker Compose operations\ncompose_up() {\n    if [[ -f "$DOCKER_COMPOSE_FILE" ]]; then\n        echo -e "${BLUE}Starting Docker Compose services...${NC}"\n        docker-compose up -d\n        echo -e "${GREEN}\u2713 Docker Compose services started${NC}"\n    else\n        echo -e "${YELLOW}Warning: $DOCKER_COMPOSE_FILE not found${NC}"\n    fi\n}\n\ncompose_down() {\n    if [[ -f "$DOCKER_COMPOSE_FILE" ]]; then\n        echo -e "${BLUE}Stopping Docker Compose services...${NC}"\n        docker-compose down\n        echo -e "${GREEN}\u2713 Docker Compose services stopped${NC}"\n    else\n        echo -e "${YELLOW}Warning: $DOCKER_COMPOSE_FILE not found${NC}"\n    fi\n}\n\n# System cleanup\ncleanup_docker() {\n    echo -e "${BLUE}Cleaning up Docker system...${NC}"\n    \n    # Remove stopped containers\n    local stopped_containers=$(docker ps -aq --filter "status=exited")\n    if [[ -n "$stopped_containers" ]]; then\n        docker rm $stopped_containers\n        echo -e "${GREEN}\u2713 Removed stopped containers${NC}"\n    fi\n    \n    # Remove unused images\n    docker image prune -f\n    echo -e "${GREEN}\u2713 Removed unused images${NC}"\n    \n    # Remove unused volumes\n    docker volume prune -f\n    echo -e "${GREEN}\u2713 Removed unused volumes${NC}"\n    \n    # Remove unused networks\n    docker network prune -f\n    echo -e "${GREEN}\u2713 Removed unused networks${NC}"\n}\n\n# Show Docker system information\nshow_system_info() {\n    echo -e "${BLUE}=== DOCKER SYSTEM INFO ===${NC}"\n    docker system df\n    echo\n    docker info | grep -E "Containers|Images|Server Version"\n}\n\n# Usage information\nusage() {\n    cat << EOF\nDocker Management Script\n\nUsage: $0 [COMMAND] [OPTIONS]\n\nCommands:\n    list [all]              List running containers (or all with \'all\')\n    start <container>       Start a container\n    stop <container>        Stop a container\n    create <image> <name> [port] [env]  Create and run a container\n    compose-up              Start Docker Compose services\n    compose-down            Stop Docker Compose services\n    cleanup                 Clean up unused Docker resources\n    info                    Show Docker system information\n    help                    Show this help message\n\nExamples:\n    $0 list\n    $0 start nginx-container\n    $0 create nginx:alpine my-nginx "8080:80" "-e ENV=production"\n    $0 compose-up\n    $0 cleanup\n\nEOF\n}\n\n# Main function\nmain() {\n    check_docker\n    \n    case "${1:-help}" in\n        list)\n            list_containers "${2:-false}"\n            ;;\n        start)\n            if [[ -z "${2:-}" ]]; then\n                echo -e "${RED}Error: Container name required${NC}"\n                exit 1\n            fi\n            start_container "$2"\n            ;;\n        stop)\n            if [[ -z "${2:-}" ]]; then\n                echo -e "${RED}Error: Container name required${NC}"\n                exit 1\n            fi\n            stop_container "$2"\n            ;;\n        create)\n            if [[ -z "${2:-}" ]] || [[ -z "${3:-}" ]]; then\n                echo -e "${RED}Error: Image name and container name required${NC}"\n                exit 1\n            fi\n            create_container "$2" "$3" "${4:-}" "${5:-}"\n            ;;\n        compose-up)\n            compose_up\n            ;;\n        compose-down)\n            compose_down\n            ;;\n        cleanup)\n            cleanup_docker\n            ;;\n        info)\n            show_system_info\n            ;;\n        help|*)\n            usage\n            ;;\n    esac\n}\n\n# Execute main function\nmain "$@"\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"-step-3-cicd-pipeline-script",children:"\ud83d\udcc1 Step 3: CI/CD Pipeline Script"}),"\n",(0,t.jsxs)(e.p,{children:["Create a deployment script ",(0,t.jsx)(e.code,{children:"deploy.sh"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:'#!/bin/bash\n\n# Deployment Script for CI/CD Pipeline\nset -euo pipefail\n\n# Configuration\nAPP_NAME="myapp"\nDOCKER_REGISTRY="registry.example.com"\nDOCKER_IMAGE="$DOCKER_REGISTRY/$APP_NAME"\nDEPLOY_ENV="${DEPLOY_ENV:-staging}"\nBUILD_NUMBER="${BUILD_NUMBER:-$(date +%s)}"\nHEALTH_CHECK_URL="http://localhost:8080/health"\n\n# Colors\nRED=\'\\033[0;31m\'\nGREEN=\'\\033[0;32m\'\nYELLOW=\'\\033[1;33m\'\nBLUE=\'\\033[0;34m\'\nNC=\'\\033[0m\'\n\n# Logging\nlog() {\n    echo "$(date \'+%Y-%m-%d %H:%M:%S\') [$1] ${*:2}"\n}\n\n# Error handling\nerror_exit() {\n    log "ERROR" "$1"\n    exit 1\n}\n\n# Pre-deployment checks\npre_deployment_checks() {\n    log "INFO" "Running pre-deployment checks..."\n    \n    # Check if Docker is available\n    if ! command -v docker &> /dev/null; then\n        error_exit "Docker is not installed"\n    fi\n    \n    # Check if required environment variables are set\n    if [[ -z "${DOCKER_REGISTRY_TOKEN:-}" ]]; then\n        error_exit "DOCKER_REGISTRY_TOKEN environment variable is not set"\n    fi\n    \n    # Check if application configuration exists\n    if [[ ! -f "config/$DEPLOY_ENV.yml" ]]; then\n        error_exit "Configuration file for $DEPLOY_ENV environment not found"\n    fi\n    \n    log "INFO" "Pre-deployment checks passed"\n}\n\n# Build Docker image\nbuild_image() {\n    log "INFO" "Building Docker image..."\n    \n    local image_tag="$DOCKER_IMAGE:$BUILD_NUMBER"\n    local latest_tag="$DOCKER_IMAGE:latest"\n    \n    # Build image\n    docker build -t "$image_tag" -t "$latest_tag" .\n    \n    if [[ $? -eq 0 ]]; then\n        log "INFO" "Docker image built successfully: $image_tag"\n    else\n        error_exit "Failed to build Docker image"\n    fi\n    \n    # Push to registry\n    log "INFO" "Pushing image to registry..."\n    \n    echo "$DOCKER_REGISTRY_TOKEN" | docker login "$DOCKER_REGISTRY" --username "$DOCKER_REGISTRY_USER" --password-stdin\n    \n    docker push "$image_tag"\n    docker push "$latest_tag"\n    \n    log "INFO" "Image pushed to registry successfully"\n}\n\n# Deploy application\ndeploy_application() {\n    log "INFO" "Deploying application to $DEPLOY_ENV environment..."\n    \n    local image_tag="$DOCKER_IMAGE:$BUILD_NUMBER"\n    \n    # Stop existing container\n    if docker ps -q --filter "name=$APP_NAME" | grep -q .; then\n        log "INFO" "Stopping existing container..."\n        docker stop "$APP_NAME" || true\n        docker rm "$APP_NAME" || true\n    fi\n    \n    # Start new container\n    docker run -d \\\n        --name "$APP_NAME" \\\n        --restart unless-stopped \\\n        -p 8080:8080 \\\n        -e ENVIRONMENT="$DEPLOY_ENV" \\\n        -e BUILD_NUMBER="$BUILD_NUMBER" \\\n        -v "$(pwd)/config/$DEPLOY_ENV.yml:/app/config.yml:ro" \\\n        "$image_tag"\n    \n    if [[ $? -eq 0 ]]; then\n        log "INFO" "Application deployed successfully"\n    else\n        error_exit "Failed to deploy application"\n    fi\n}\n\n# Health check\nhealth_check() {\n    log "INFO" "Performing health check..."\n    \n    local max_attempts=30\n    local attempt=1\n    \n    while [[ $attempt -le $max_attempts ]]; do\n        if curl -f -s "$HEALTH_CHECK_URL" > /dev/null; then\n            log "INFO" "Health check passed"\n            return 0\n        fi\n        \n        log "INFO" "Health check attempt $attempt/$max_attempts failed, retrying in 10 seconds..."\n        sleep 10\n        ((attempt++))\n    done\n    \n    error_exit "Health check failed after $max_attempts attempts"\n}\n\n# Rollback function\nrollback() {\n    log "WARN" "Rolling back deployment..."\n    \n    local previous_image="$DOCKER_IMAGE:previous"\n    \n    # Stop current container\n    docker stop "$APP_NAME" || true\n    docker rm "$APP_NAME" || true\n    \n    # Start previous version\n    docker run -d \\\n        --name "$APP_NAME" \\\n        --restart unless-stopped \\\n        -p 8080:8080 \\\n        -e ENVIRONMENT="$DEPLOY_ENV" \\\n        -v "$(pwd)/config/$DEPLOY_ENV.yml:/app/config.yml:ro" \\\n        "$previous_image"\n    \n    log "INFO" "Rollback completed"\n}\n\n# Cleanup old images\ncleanup() {\n    log "INFO" "Cleaning up old Docker images..."\n    \n    # Keep only the last 5 images\n    docker images "$DOCKER_IMAGE" --format "{{.Tag}}" | \\\n        grep -E \'^[0-9]+$\' | \\\n        sort -nr | \\\n        tail -n +6 | \\\n        xargs -I {} docker rmi "$DOCKER_IMAGE:{}" || true\n    \n    log "INFO" "Cleanup completed"\n}\n\n# Main deployment function\nmain() {\n    log "INFO" "Starting deployment process for $APP_NAME (Build: $BUILD_NUMBER, Environment: $DEPLOY_ENV)"\n    \n    # Tag current image as previous for rollback\n    if docker images -q "$DOCKER_IMAGE:latest" | grep -q .; then\n        docker tag "$DOCKER_IMAGE:latest" "$DOCKER_IMAGE:previous"\n    fi\n    \n    pre_deployment_checks\n    build_image\n    deploy_application\n    \n    # Wait a moment for the application to start\n    sleep 15\n    \n    if health_check; then\n        log "INFO" "Deployment successful!"\n        cleanup\n    else\n        log "ERROR" "Deployment failed, initiating rollback..."\n        rollback\n        exit 1\n    fi\n}\n\n# Handle script arguments\ncase "${1:-deploy}" in\n    deploy)\n        main\n        ;;\n    rollback)\n        rollback\n        ;;\n    health-check)\n        health_check\n        ;;\n    cleanup)\n        cleanup\n        ;;\n    *)\n        echo "Usage: $0 {deploy|rollback|health-check|cleanup}"\n        exit 1\n        ;;\nesac\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"\ufe0f-step-4-run-the-scripts",children:"\u25b6\ufe0f Step 4: Run the Scripts"}),"\n",(0,t.jsx)(e.p,{children:"Make scripts executable and run them:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:'# Make scripts executable\nchmod +x system-monitor.sh docker-manager.sh deploy.sh\n\n# Run system monitoring\n./system-monitor.sh\n\n# Docker management examples\n./docker-manager.sh list\n./docker-manager.sh create nginx:alpine my-nginx "8080:80"\n./docker-manager.sh info\n\n# Deployment (in CI/CD environment)\nexport DOCKER_REGISTRY_TOKEN="your-token"\nexport DOCKER_REGISTRY_USER="your-username"\nexport DEPLOY_ENV="staging"\n./deploy.sh\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"-what-youll-see",children:"\ud83d\udd0d What You'll See"}),"\n",(0,t.jsx)(e.h3,{id:"system-monitor-output",children:"System Monitor Output"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"=== SYSTEM MONITORING REPORT ===\nGenerated on: 2024-01-15 10:30:00\nHostname: web-server-01\n\n=== SYSTEM INFORMATION ===\nHostname: web-server-01\nDate: Mon Jan 15 10:30:00 UTC 2024\nUptime: 10:30:00 up 5 days, 2:15, 1 user, load average: 0.15, 0.10, 0.05\nKernel: 5.4.0-74-generic\nOS: Ubuntu 20.04.3 LTS\nArchitecture: x86_64\n\n=== MEMORY USAGE ===\n              total        used        free      shared  buff/cache   available\nMem:           7.8G        2.1G        3.2G        180M        2.5G        5.3G\nSwap:          2.0G          0B        2.0G\n\nMemory usage: 26.92%\n\n=== SERVICE STATUS ===\n\u2713 nginx: Running\n\u2713 docker: Running\n\u2717 mysql: Stopped\n? postgresql: Not installed\n"})}),"\n",(0,t.jsx)(e.h3,{id:"docker-manager",children:"Docker Manager"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Container Management"}),": Start, stop, create containers"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"System Information"}),": Resource usage and statistics"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Cleanup Operations"}),": Remove unused resources"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Compose Integration"}),": Manage multi-container applications"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"deployment-pipeline",children:"Deployment Pipeline"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Build Process"}),": Docker image creation and registry push"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Health Checks"}),": Automated application health verification"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Rollback Capability"}),": Automatic rollback on deployment failure"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Cleanup"}),": Old image and resource cleanup"]}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pros--cons",children:"Pros & Cons"}),"\n",(0,t.jsx)(e.h3,{id:"-pros",children:"\u2705 Pros"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Universal"}),": Available on all Unix-like systems"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Lightweight"}),": Minimal resource usage"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Powerful"}),": Rich ecosystem of command-line tools"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Flexible"}),": Easy text processing and system interaction"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Fast"}),": Direct system calls and efficient execution"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Portable"}),": Scripts work across different Unix systems"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"-cons",children:"\u274c Cons"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Platform Limited"}),": Primarily Unix/Linux systems"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Error Prone"}),": Easy to make mistakes without proper error handling"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Limited Data Structures"}),": Basic variable and array support"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Debugging"}),": Can be challenging to debug complex scripts"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Syntax"}),": Can be cryptic for complex operations"]}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsxs)(e.p,{children:["Bash scripting is essential for ",(0,t.jsx)(e.strong,{children:"Linux/Unix system administration"})," and ",(0,t.jsx)(e.strong,{children:"DevOps automation"}),". Choose Bash when you need:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"System-level"})," automation and administration"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"CI/CD pipeline"})," scripts and automation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Text processing"})," and log analysis"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Infrastructure"})," provisioning and management"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Lightweight"})," automation without additional dependencies"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"Bash remains the backbone of Unix system administration and is indispensable for DevOps workflows on Linux systems."}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"What You've Achieved:"}),"\n\u2705 Created comprehensive system monitoring scripts",(0,t.jsx)(e.br,{}),"\n","\u2705 Built Docker container management automation",(0,t.jsx)(e.br,{}),"\n","\u2705 Implemented CI/CD deployment pipelines",(0,t.jsx)(e.br,{}),"\n","\u2705 Established error handling and logging practices",(0,t.jsx)(e.br,{}),"\n","\u2705 Developed production-ready automation scripts"]})]})}function h(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}}}]);